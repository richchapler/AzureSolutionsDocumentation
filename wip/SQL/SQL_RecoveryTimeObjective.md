# SQL Server, Recovery Time Objective (RTO)

## Sources

- **[Monitor performance for Always On availability groups >> Estimate failover time (RTO)](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20failure%20detection%20time%2C%20Tdetection%2C,the%20SQL%20Server%20instance%20has)**  
  Explains how RTO is calculated by breaking it into three main components:
  - **Detection Time (Tdetection)**: Time to recognize primary replica failure.
  - **Redo Time (Tredo)**: Time required for secondary replica to apply remaining logs.
  - **Failover Overhead (Toverhead)**: Time needed to transition roles and bring databases online.
  
  Provides the formula to estimate total failover time and clarifies which metrics directly impact achieving sub-minute RTO goals.

- **[Failover and Failover Modes (Always On Availability Groups)](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups?view=sql-server-ver16)**  
  Highlights the relationship between availability modes (synchronous/asynchronous) and failover modes (automatic/manual), emphasizing:
  - **Automatic failover (Synchronous mode)**: Minimal RTO, typically seconds to under a minute.
  - **Manual failover (Asynchronous mode)**: Higher RTO, due to required manual intervention and potential data loss.
  
  Clarifies how choosing the right mode directly affects achieving your RTO target.

- **[Accelerated Database Recovery](https://learn.microsoft.com/en-us/sql/relational-databases/accelerated-database-recovery-concepts?view=sql-server-ver16#:~:text=Accelerated%20database%20recovery%20,the%20database%20engine%20recovery%20process)**  
  Describes how Accelerated Database Recovery (ADR) significantly reduces database recovery times, thereby shortening the **Redo Time (Tredo)** component of the RTO calculation. ADR ensures that even long-running transactions no longer delay recovery, making sub-minute RTO achievable under broader workload conditions.

- **[Troubleshoot: Availability group exceeded RTO](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/troubleshoot-availability-group-exceeded-rto?view=sql-server-ver16#:~:text=The%20redo%20thread%20on%20the,only%20query)**  
  Discusses how issues like redo thread blocking (caused by secondary replica workloads) can delay recovery and cause exceedance of planned RTO. It provides troubleshooting advice to:
  - Identify causes of increased redo queue lengths.
  - Mitigate factors that increase redo times.
  
  Highlights the importance of proactively managing secondary workloads to consistently meet low RTO targets.

-------------------------

## Synchronous vs. Asynchronous Commit Modes 
Always On availability groups support two replication modes – **synchronous-commit** and **asynchronous-commit** – which significantly impact RTO and failover behavior. A synchronous-commit secondary replica can be configured for **automatic failover** with zero data loss (RPO = 0) as long as it is fully synchronized with the primary ([Failover modes for availability groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups?view=sql-server-ver16#:~:text=%2A%20Synchronous,secondary%20replica%20with%20a%20healthy)). In contrast, an asynchronous-commit replica does **not** stay fully synchronized in real-time and therefore only supports manual failover (typically a *forced* failover with possible data loss) ([Failover modes for availability groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups?view=sql-server-ver16#:~:text=%2A%20Asynchronous,they%20support%20only%20forced%20failover)). In practice, this means synchronous replication is used for high availability (HA) with fast, automatic failovers, whereas asynchronous replication is often used for disaster recovery (DR) where some data latency is tolerated and failover is a manual, planned operation.

**Automatic vs. Manual Failover:** With synchronous commit, you can configure one or more secondary replicas for *automatic failover*. If the primary fails, the WSFC cluster automatically promotes a synchronized secondary to primary within seconds (no data loss) ([Failover modes for availability groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups?view=sql-server-ver16#:~:text=%2A%20Synchronous,secondary%20replica%20with%20a%20healthy)). Asynchronous secondaries cannot be failed over automatically (to avoid data loss); you must manually initiate failover, and any unsent log on the primary may be lost ([Failover modes for availability groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups?view=sql-server-ver16#:~:text=%2A%20Asynchronous,they%20support%20only%20forced%20failover)). Thus, asynchronous commit usually results in higher RTO because an operator needs to confirm and execute the failover (often waiting to ensure all possible data is replicated or accepting some loss). Synchronous commit with automatic failover is the recommended configuration when you need the lowest possible RTO.

## Failover Time Components and Estimation 
Microsoft’s documentation breaks down **failover time** (which determines RTO) into three components ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=Image%3A%20Screenshot%20of%20Availability%20groups,redo%20time%20calculation)):

- **Failure detection time (T_detection):** Time for the system to recognize the primary has failed. This depends on WSFC cluster settings and the failure conditions. By default, the cluster’s health check timeout is 30 seconds, and the AG resource “lease” timeout is 20 seconds ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=critical%20SQL%20Server%20internal%20error%2C,13%20Flexible%20failover%20policy%20for)). In a worst-case scenario (no pings), detection takes up to the timeout (around 30 seconds by default) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=critical%20SQL%20Server%20internal%20error%2C,13%20Flexible%20failover%20policy%20for)). However, SQL Server can signal certain critical failures to the cluster almost immediately. For example, with the default flexible failover policy (failure condition level 3, “critical server error”), a serious internal error triggers an alert to WSFC as soon as it’s detected – the cluster doesn’t have to wait the full interval ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20failure%20detection%20time%2C%20Tdetection%2C,the%20SQL%20Server%20instance%20has)). In such cases, **detection can be as fast as ~10 seconds** (since the `sp_server_diagnostics` heartbeat reports every 1/3 of the timeout by default) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=individual%20availability%20replicas,the%20SQL%20Server%20instance%20has)). You can also adjust the **health check timeout** (down to a minimum of 15,000 ms) to tune how quickly a missed heartbeat triggers failover ([Configure a flexible automatic failover policy for an availability group - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-flexible-automatic-failover-policy?view=sql-server-ver16&viewFallbackFrom=sql-server-2014#:~:text=,30%20seconds)). Shorter detection times lead to faster failover (lower RTO) at the risk of sensitivity to transient network hiccups.

- **Redo catch-up time (T_redo):** Time for the chosen secondary to apply any remaining log records and finish recovery. The secondary must replay all transmitted log up to the end of the primary’s log to bring the database to the current point in time. If the secondary was truly synchronized (synchronous commit with little or no log backlog), this redo time is minimal. Microsoft provides a formula: the **redo time** can be estimated as `redo_queue_size / redo_rate` ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=Image%3A%20Screenshot%20of%20Availability%20groups,redo%20time%20calculation)). In other words, the outstanding log bytes on the secondary divided by the redo throughput gives the time to catch up. A secondary in the **“Synchronized” state will typically have a near-zero redo queue**, so T_redo is often just a few seconds or less. However, if the secondary is behind (e.g. an asynchronous replica with a large log send queue or a sync replica that fell behind due to load), the redo phase can add significant time. For instance, a large redo queue or slow redo rate will increase RTO proportionally. It’s important to monitor the *Estimated Recovery Time (seconds)* for secondaries – SQL Server’s AG dashboard exposes this metric – as it reflects how long that replica would take to catch up if a failover occurred ([Monitor Performance for Availability Groups - SQL Server Always On](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=On%20learn,RPO)).

- **Failover overhead (T_overhead):** Time to actually switch roles in the cluster and bring databases online on the new primary. This includes WSFC processing the failover, reconnecting the AG resources, and the SQL instance activating the databases as primaries. According to Microsoft, this overhead is usually **short and fairly constant** ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20failover%20overhead%20time%2C%20Toverhead%2C,is%20usually%20short%20and%20constant)). It might involve a brief additional delay for the new primary databases to go online (e.g. a few seconds to finalize the role change). In planning, Microsoft sometimes assumes ~60 seconds as a buffer for detection + failover overhead ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=)) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=This%20condition%20fails%20when%20potential,both%20failure%20detection%20and%20failover)), but in well-tuned systems the actual failover overhead (excluding redo) is typically only a handful of seconds.

These components sum up to the total failover time: 

\[ **T_failover = T_detection + T_redo + T_overhead** \]

This formula (outlined in Microsoft’s documentation) makes it clear that to achieve a low RTO, you want to minimize each of these factors ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=Image%3A%20Screenshot%20of%20Availability%20groups,redo%20time%20calculation)). If an availability group contains multiple databases, note that the **slowest database (highest T_failover)** will govern the AG’s overall failover time – the failover isn’t complete until all databases are recovered on the new primary ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=If%20an%20availability%20group%20contains,limiting%20value%20for%20RTO%20compliance)). So, any one large or slow-recovering database can become the bottleneck for RTO compliance in that AG.

## Achieving Sub-One-Minute Failovers 
Official Microsoft guidance suggests that **failovers can be very fast – often well under one minute – under the right configuration**. The optimal scenario is a synchronous-commit secondary with automatic failover, no significant lag, and no long transactions to roll back. In this case, the primary failure is detected quickly and the secondary has very little to do to take over.

- **Fast detection:** With default cluster settings, detection might take ~30 seconds in a worst case timeout scenario ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=to%20the%20Windows%20Server%20Failover,13%20Flexible%20failover%20policy%20for)). But many failures are detected much faster. If SQL Server crashes or hits a critical error, the cluster can initiate failover almost immediately (the next health check cycle, which by default is ~10 seconds) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=individual%20availability%20replicas,the%20SQL%20Server%20instance%20has)). If faster RTO is needed, an administrator can also configure more aggressive failover conditions (for example, treating moderate errors as trigger conditions) or reduce the health check interval to  quinze seconds (15,000 ms) ([Configure a flexible automatic failover policy for an availability group - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-flexible-automatic-failover-policy?view=sql-server-ver16&viewFallbackFrom=sql-server-2014#:~:text=,30%20seconds)). This means the system could detect and start failover in as little as 15–20 seconds in some cases.

- **Minimal redo:** With synchronous replication, a secondary in *Synchronized* state has already hardened every transaction log record to disk as part of each commit. Upon failover, there should be **near-zero redo lag** – essentially the secondary just needs to apply any log records that were in flight. For example, if the primary went down *just* before committing a transaction, the log block might already be sent and waiting in the secondary’s redo queue. The redo thread will apply it almost immediately. The **redo catch-up time can thus be only a few seconds or less** for a truly synchronized secondary ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20only%20thing%20that%20the,calculated%20using%20the%20following%20formula)). SQL Server 2019 and later further improve this with features like **Parallel Redo** (multiple redo threads per database) to speed up recovery. Parallel redo, introduced in SQL 2016, greatly reduces redo time for workloads with many small transactions by using multiple CPU threads to apply log records ([SQL Server 2016/2017: Availability group secondary replica redo model and performance | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/sqlserver/sql-server-20162017-availability-group-secondary-replica-redo-model-and-performa/385905#:~:text=transaction%20log%20redo%20was%20handled,as%20when%20data%20encryption%20and%2For)). The net effect is that the secondary can catch up and finish recovery very quickly, even under load.

- **Fast recovery (ADR):** Another important enhancement in SQL Server 2019+ is **Accelerated Database Recovery (ADR)**. ADR redesigns the recovery process so that database startup (redo/undo) time is **fast and predictable regardless of transaction size** ([Accelerated Database Recovery (ADR) - SQL Server | Microsoft Learn](https://learn.microsoft.com/en-us/sql/relational-databases/accelerated-database-recovery-concepts?view=sql-server-ver16#:~:text=,recovery)). Long-running transactions no longer delay recovery; uncommitted changes are versioned and can be rolled back instantaneously using the persisted version store. This means that after a failover, the new primary database can come online much faster, since it avoids lengthy undo phases. Microsoft notes that ADR *“improves database availability, especially in the presence of long-running transactions, by redesigning the database engine recovery process.”* ([Accelerated Database Recovery (ADR) - SQL Server | Microsoft Learn](https://learn.microsoft.com/en-us/sql/relational-databases/accelerated-database-recovery-concepts?view=sql-server-ver16#:~:text=Accelerated%20database%20recovery%20,the%20database%20engine%20recovery%20process)) In practice, if ADR is enabled on the databases, even a large open transaction will not slow down the failover recovery – the abort happens almost instantly. This helps keep the **RTO within seconds** in scenarios that previously might have taken minutes or longer to recover.

Given these factors, a well-tuned Always On AG can indeed fail over typically in the **tens of seconds** range. For example, with a default WSFC timeout (~30s) and a synchronized secondary that has negligible redo work, you might see failover complete in roughly 30–40 seconds. In more aggressive configurations (or in a planned manual failover where the primary is still online to synchronize last changes), it could be even faster. The combination of synchronous commit (no data to catch up) and features like ADR and parallel redo (rapid recovery) allows **meeting an RTO of under one minute**. Official Microsoft documentation implicitly validates this by describing detection in ~seconds and stating that failover overhead is small ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20failure%20detection%20time%2C%20Tdetection%2C,the%20SQL%20Server%20instance%20has)) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20failover%20overhead%20time%2C%20Toverhead%2C,is%20usually%20short%20and%20constant)). Essentially, the only significant wait in an ideal case is the cluster detection delay, which by design can be on the order of a few seconds to a few tens of seconds. Everything after that (redo and database online) is usually very quick. 

It’s worth noting that client applications may experience a brief interruption during failover (connections drop and need to reconnect to the new primary). In many cases, this interruption is on the order of the same failover duration – e.g. 30 seconds or so by default. Techniques like using an AG **listener** with the `MultiSubnetFailover=True` connection string option (for multi-subnet deployments) can minimize DNS reconnection delays, ensuring the app is back online as soon as SQL has failed over. This is more about application-level failover, but it helps realize the sub-minute recovery at the user end as well.

## Tuning and Best Practices to Improve Failover RTO 
To ensure the fastest possible failovers (and thereby a low RTO), consider the following configurations and tuning parameters, all of which are highlighted in Microsoft’s documentation:

- **Use Synchronous Commit with Automatic Failover:** For mission-critical databases that need ~zero downtime, use synchronous-commit mode and enable automatic failover to a secondary replica. This guarantees no data loss on failover and the secondary is ready to take over immediately ([Failover modes for availability groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups?view=sql-server-ver16#:~:text=%2A%20Synchronous,secondary%20replica%20with%20a%20healthy)). Asynchronous replicas should be reserved for scenarios where a slight delay and manual intervention are acceptable (e.g. geo-dr sites), since by design they will have higher RTO (the AG won’t auto-failover and may need to catch up logs or sacrifice some data) ([Failover modes for availability groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups?view=sql-server-ver16#:~:text=%2A%20Asynchronous,they%20support%20only%20forced%20failover)).

- **Leverage Flexible Failover Policy:** Always On allows you to configure **failure conditions and health check timeouts** to suit your RTO needs. By default, failover condition level 3 is used (automatic failover on critical server errors or obvious server down scenarios) ([Configure a flexible automatic failover policy for an availability group - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-flexible-automatic-failover-policy?view=sql-server-ver16&viewFallbackFrom=sql-server-2014#:~:text=threshold%20is%20exceeded%2C%20or%20the,internal%20critical%20server%20error%20occurs)). If you require more aggressive failover (for example, failing over on moderate errors or even any qualifying error), you can increase the sensitivity (levels 4 or 5). Conversely, to avoid false failovers, you might use a lower sensitivity. Similarly, you can adjust the **HEALTH_CHECK_TIMEOUT** for the AG resource – default is 30,000 ms. Lowering this to 15,000 ms (15s) will trigger faster detection ([Configure a flexible automatic failover policy for an availability group - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-flexible-automatic-failover-policy?view=sql-server-ver16&viewFallbackFrom=sql-server-2014#:~:text=,30%20seconds)). The trade-off is that shorter timeouts might cause failover on transient issues, so find a balance that meets your SLA. Microsoft’s documentation notes that by tweaking these settings (failover condition level and timeout), you can **“increase or decrease the likelihood of an automatic failover to support your SLA for high availability.”** ([Configure a flexible automatic failover policy for an availability group - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-flexible-automatic-failover-policy?view=sql-server-ver16&viewFallbackFrom=sql-server-2014#:~:text=This%20topic%20describes%20how%20to,your%20SLA%20for%20high%20availability)) In summary, tune the cluster’s heartbeat and failure conditions so that failovers happen as quickly as safely possible.

- **Avoid Redo Bottlenecks:** The secondary’s redo thread must keep up with incoming log data. If it falls behind, your *Estimated Recovery Time* (RTO) grows. Monitor performance counters and DMVs like `redo_queue_size` and `redo_rate` (available in `sys.dm_hadr_database_replica_states`) to ensure the redo queue isn’t building up significantly ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=Image%3A%20Screenshot%20of%20Availability%20groups,redo%20time%20calculation)). A common issue is long-running read-only queries on secondary replicas that block redo. Microsoft warns that a long report or backup query can hold schema-stability locks and **stop the redo thread from making progress**, which directly delays failover because the secondary cannot finish applying log while it’s blocked ([Troubleshoot: Availability group exceeded RTO (SQL Server) - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/troubleshoot-availability-group-exceeded-rto?view=sql-server-ver16#:~:text=The%20redo%20thread%20on%20the,only%20query)). The solution is to manage secondary workloads: use the `READ_COMMITTED_SNAPSHOT` isolation for secondary queries if possible, or enable *Readable Secondary* with care. If a reporting workload is needed, consider offloading it to a different secondary (one not intended to be the failover target), or ensure such queries are killed quickly during failover events. Keeping secondaries free to apply log ensures T_redo remains low.

- **Apply Accelerated Database Recovery (ADR):** As mentioned, enabling ADR on user databases can drastically reduce recovery time. This helps not only crash recovery but also AG failovers. With ADR, even if your workload has occasional big transactions or bulk operations, the time to bring the database online after failover remains consistent and fast ([Accelerated Database Recovery (ADR) - SQL Server | Microsoft Learn](https://learn.microsoft.com/en-us/sql/relational-databases/accelerated-database-recovery-concepts?view=sql-server-ver16#:~:text=Accelerated%20database%20recovery%20,the%20database%20engine%20recovery%20process)) ([Accelerated Database Recovery (ADR) - SQL Server | Microsoft Learn](https://learn.microsoft.com/en-us/sql/relational-databases/accelerated-database-recovery-concepts?view=sql-server-ver16#:~:text=,recovery)). For SQL Server 2019, ADR is available (but not enabled by default – you must enable it per database). In Azure SQL and SQL Server 2022, ADR is on by default. Make sure to test ADR with your workload, but it is a powerful feature to meet strict RTO goals.

- **Manage Transaction Log Throughput:** The **log send queue** on the primary and network throughput to secondaries also affect RTO (especially for async replicas). Ensure sufficient network bandwidth and low latency between primary and synchronous secondary so that log blocks ship quickly. In SQL Server 2019+, there were improvements (e.g. trace flag 12310 or built-in in 2022) to allow more log message concurrency for AGs, reducing any throttling of log transport ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=SQL%20Server%202022%20%2816,x%29%20SP1%20CU16)) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=For%20versions%20of%20SQL%20Server,versions%2C%20see%20the%20following%20limits)). Keeping the log transport pipeline healthy means the secondary is as up-to-date as possible at any moment, minimizing catch-up time. If using asynchronous commit for DR, consider periodically forcing a sync or at least monitoring the *Estimated Data Loss* metric – while not directly an RTO metric, a very large log send queue could translate to a very long redo if you ever had to fail over.

- **Monitor AG Dashboard Metrics:** SQL Server provides built-in monitoring for RTO/RPO. In SQL Server Management Studio’s *Always On Dashboard*, you can add columns for **Estimated Recovery Time (seconds)** and **Estimated Data Loss (time)** ([Monitor Performance for Availability Groups - SQL Server Always On](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=On%20learn,RPO)). These give a live estimate of the RTO (failover time) and RPO (data loss) for each secondary replica. If you see the estimated failover time climbing above your target (e.g. above 60 seconds), that’s a sign to investigate lag or performance issues in the AG. Microsoft also suggests implementing Policy-Based Management or alerts on these metrics – for example, an alert if estimated RTO exceeds a certain threshold ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=,minutes%2C%20evaluated%20every%205%20minutes)) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=,Value%3A%20%60600)). By keeping an eye on these, you can be confident that your AG is positioned to fail over quickly when needed.

- **SQL Server 2019+ Features:** Besides ADR, note that SQL Server 2019 increased the maximum number of synchronous secondary replicas from 3 to **5** ([Configure a flexible automatic failover policy for an availability group - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-flexible-automatic-failover-policy?view=sql-server-ver16&viewFallbackFrom=sql-server-2014#:~:text=,plus%20four%20synchronous%20secondary%20replicas)). You can have multiple automatic failover targets in a group (though only one will failover at a time). This doesn’t speed up a single failover, but it can improve overall HA by providing additional synced replicas (perhaps in different AZs or data centers) ready to take over. Also, features like **secondary-to-primary connection redirection** (SQL 2019) and **contained AGs** (SQL 2022) aim to reduce application reconnection time and management overhead during failovers – indirectly contributing to a smoother, quicker recovery. Always ensure your AG’s listener is configured correctly, and for multi-subnet scenarios use `MultiSubnetFailover=True` so that the client driver quickly finds the new primary’s IP after failover (this avoids waiting for DNS updates and keeps the application outage window as small as the database failover itself).

In summary, **official Microsoft documentation and guidance confirm that sub-minute failovers are achievable** with Always On, provided you use synchronous commit with automatic failover and optimize the environment for fast detection and recovery. The key is to eliminate any roadblocks in the failover process – detect failures quickly, keep secondaries caught up (redo queue low), and use features that streamline recovery. Microsoft’s formula for RTO and their best practices (tunable failover policies, health checks, ADR, etc.) all reinforce that a properly configured SQL Server 2019+ Always On deployment can meet very aggressive RTO targets (often **30 seconds or less for failover** in a LAN environment) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20failure%20detection%20time%2C%20Tdetection%2C,the%20SQL%20Server%20instance%20has)) ([Monitor Performance for Availability Groups - SQL Server Always On | Microsoft Learn](https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups?view=sql-server-ver16#:~:text=The%20failover%20overhead%20time%2C%20Toverhead%2C,is%20usually%20short%20and%20constant)). By contrast, if you run in asynchronous mode or have heavy workloads that lag the secondaries, your failover could take longer (minutes), so it’s important to align the configuration with your RTO requirements. All the evidence – from Microsoft’s docs to their tech community articles – supports the idea that *“near-zero” downtime (RTO in seconds) is possible with Always On* when using synchronous replication and proper tuning, validating the <1 minute failover objective in practice. 
